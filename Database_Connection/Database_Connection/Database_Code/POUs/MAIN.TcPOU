<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{4ef234f8-6ebd-4fcd-beba-a435a8463d67}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	
    //database variables
	FB_SQLDatabaseEvt : FB_SQLDatabaseEvt(sNetID := '', tTimeout := T#5S);
    FB_SQLCommandEvt  : FB_SQLCommandEvt(sNetID := '', tTimeout := T#5S);
    FB_SQLResultEvt   : FB_SQLResultEvt(sNetID := '', tTimeout := T#5S);
	SQL_Commands: ARRAY[1..7] OF STRING(500);
	sSelectDataCommand : STRING(255);
	DataBase_Connection: BOOL := FALSE;
   
	//inputs from sensor
    iLoadCellValue AT %I*: INT;
	iLoadCellPreviousValue : INT;
	iTempSensor1Value AT %I*: INT;
	iTempSensor2Value AT %I*: INT;
	iTempSensor3Value AT %I*: INT;
	iTempSensor4Value AT %I*: INT;
	iEncoderValue AT %I*: UDINT;
	iLichtSluisValue1 AT %I* : BOOL;
	iLichtSluisValue2 AT %I* : BOOL;
	iCapacitiefValue AT %I* : INT;
	
	tInsertTimer: TON; (* Timer to control insert intervals *)
    tInsertInterval: TIME := T#10S; (* 10-second interval *)
	

	//read arrays
	aReadStruct : ARRAY[1..10] OF TempSensor_SelectStruct;
	//Strings to insert
	sTempSensor1Value: STRING(255);
	sTempSensor2Value: STRING(255);
	sTempSensor3Value: STRING(255);
	sTempSensor4Value: STRING(255);
	iSampleNr: INT := 1;
	iSensorIDs : ARRAY[1..4] OF INT := [1,2,3,4];
	
	
	// INSERT state machine control
	nStep, nNextStep: INT ;
	//HMI variables
	iEncoderMotor : REAL;
	iLoadCellMotor : INT;
	iMotorSpeed : INT;
	iMetingen : INT;
	iTijd : INT;
	iTijdMeting : INT;
	bConfirm : BOOL;
	
	
	bStart : BOOL;
	bStop : BOOL := TRUE;
	Process_Status : BOOL; 
	bStartEnabled: BOOL;
	bDatalogView : BOOL;
	bActuatorView : BOOL;
	
	//hmi control
	TijdConvertUitwijking : TIME;
	TijdConvertMeting : TIME;
	tUitwijkingTimer: TON; (* Timer to control wait time *) 
	tMetingTimer : TON; (* Timer to control measurement time*)
	MeasurementsCompleted : INT;
	RealMotorPosition AT %I* : UDINT;
	MeasurementState: INT;
	

	
	//motor controls
	oMotorEnable AT %Q*: BOOL;
	oMotorExecute AT %Q*: BOOL;
	oMotorVelocity AT %Q*: INT;
	oMotorPosition AT %Q*: UDINT;
	oStartPosition AT %Q* : UDINT;
	oEnableStart AT %Q* : BOOL;
	oMotorStartType AT %Q* : INT;
	oMotorReset AT %Q* : BOOL;
	iMotorStatus AT %I* : BOOL;
	iMotorCalibrated AT %I* : BOOL;
	iMotorReady AT %I* : BOOL;
	iMotorBusy AT %I* : BOOL;
	iMotorWarning AT %I* : BOOL;
	//Homing controls
	HomingEdgeR : F_TRIG;
	HomingEdgeL : F_TRIG;
	Homing : INT := 0;
	HomingDone : BOOL;
	HomingDelayTimer: TON;
	tHomingInterval: TIME := T#5S;
	HomingStartTimer : TON;
	tHomingStartInterval: TIME := T#25S;
	MotorLeftEdge : UDINT := 314000;
	MotorRightEdge : UDINT := 0;
	//timer for motor delay
	tMotorTimer: TON; (* Timer to control Motor intervals *)
    tMotorInterval: TIME := T#50MS; (* 50-Millisecond interval *)
	tHomeTimer: TON;
	tHomeInterval: TIME := T#10S;
	//test case variables
 	CycleCounter : INT := 0;
    State : INT := 0;
	TargetPosition: UDINT;
	WaitingAtMid : BOOL;
	
	
	//conversion variables
	TestForce : INT;
	Voltage: REAL;
	iEncoderDegrees: LREAL;

END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
//conversion variables
iEncoderDegrees := EncoderConvert(iEncoderValue); 
TestForce := LoadcellConvert(iLoadCellValue);
Voltage := INT_TO_REAL(iLoadCellValue)/32768 * 10.737;




//check status of motor and reset if necessary
IF iMotorStatus OR NOT iMotorCalibrated THEN
    oMotorReset := TRUE;
ELSE
    oMotorReset := FALSE;
END_IF

IF NOT HomingDone THEN
// === Edge Detection (run every cycle) ===	
HomingEdgeR(CLK := iLichtSluisValue2); // Falling edge
HomingEdgeL(CLK := iLichtSluisValue1); // Falling edge

// === Homing State Machine ===
CASE Homing OF
0: // Initialization
    oStartPosition := 157000;
    oEnableStart := TRUE;
    oEnableStart := FALSE;
    oMotorEnable := TRUE;
    oMotorVelocity := 500;
	HomingDelayTimer(PT := tHomingInterval);
	HomingStartTimer(PT := tHomingStartInterval);
    Homing := 1;

1: // Try moving CW
    IF iLichtSluisValue1 THEN
        oMotorPosition := 0;
        oMotorExecute := TRUE;
        Homing := 10;
    ELSE
        Homing := 2; // Try CCW
    END_IF

2: // Try moving CCW
    IF iLichtSluisValue2 THEN
        oMotorPosition := 314000;
        oMotorExecute := TRUE;
        Homing := 10;
    ELSE
        Homing := 1; // Back to CW
    END_IF

10: // Wait for sensor falling edge (center detected)
	HomingStartTimer(IN:= TRUE);
    IF (HomingEdgeL.Q OR HomingEdgeR.Q) OR HomingStartTimer.Q THEN
        oMotorExecute := FALSE;
        Homing := 11;
    END_IF

11: // Finalize homing
    oStartPosition := 157000;
    oEnableStart := TRUE;
	//wait for motor to turn off 
	HomingDelayTimer(IN:= TRUE);
    IF HomingDelayTimer.Q THEN
        HomingDone := TRUE;
    END_IF
END_CASE

ELSE
(*
// === Test Movement State Machine ===
CASE State OF

0: // Initialization
    oMotorVelocity := 400;
    tMotorTimer(IN := FALSE);
	tHomeTimer(PT := tHomeInterval);
    WaitingAtMid := FALSE;
    State := 1;

1: // Prepare move
    IF iMotorReady THEN
        oMotorPosition := TargetPosition;
        oMotorExecute := TRUE;
        State := 2;
    END_IF

2: // Wait for motion to midpoint or endpoint
    IF NOT WaitingAtMid AND ABS(RealMotorPosition - oStartPosition) < 100 THEN
        oMotorExecute := FALSE; // Stop motor at center
        WaitingAtMid := TRUE;
    END_IF

    IF WaitingAtMid THEN
        tHomeTimer(IN := TRUE);
        IF tHomeTimer.Q THEN
            // Start move to end after wait
            oMotorPosition := TargetPosition;
            oMotorExecute := TRUE;
            WaitingAtMid := FALSE;
            //TimerDone := TRUE; // Optional flag to track post-wait move
            tHomeTimer(IN := FALSE);
        END_IF
    ELSE
        tHomeTimer(IN := FALSE);
    END_IF

    // Wait for endpoint after resume
    IF  ABS(RealMotorPosition - TargetPosition) < 100 THEN
        oMotorExecute := FALSE; // Stop after reaching end
        //TimerDone := FALSE;
        State := 3;
    END_IF

3: // Toggle position and increment counter
    IF TargetPosition = 0 THEN
        TargetPosition := 314000;
    ELSE
        TargetPosition := 0;
    END_IF

    CycleCounter := CycleCounter + 1;

    IF CycleCounter >= 5 THEN
        State := 4;
    ELSE
        State := 1;
    END_IF

4: // Final stop
    IF iMotorReady THEN
	oMotorPosition := oStartPosition;
    oMotorExecute := TRUE;
	END_IF
    IF NOT iMotorBusy THEN
        oMotorExecute := FALSE;
    END_IF

END_CASE 


*)

(*
//make connection to the database
IF NOT DataBase_Connection THEN
    FB_SQLDatabaseEvt.Connect(hDBID := 1);  // Attempt to connect

    // Wait until the connection is established
    IF FB_SQLDatabaseEvt.bConnected THEN
        FB_SQLDatabaseEvt.CreateCmd(pSQLCommand := ADR(FB_SQLCommandEvt));
        DataBase_Connection := TRUE;
    END_IF;
END_IF


// Generate and insert LoadCell Data only when changed 
IF ABS(iLoadCellValue - iLoadCellPreviousValue) > 100  THEN
    SQL_Commands[1] := FC_SQL_InsertCommands_LoadCell(LoadcellConvert(iLoadCellValue), iSampleNr);
	FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[1]), cbSQLCmd := SIZEOF(SQL_Commands[1]));
    iSampleNr := iSampleNr + 1;  // Increment sample number
    iLoadCellPreviousValue := iLoadCellValue;  // Update previous load cell value
END_IF


	
	//INSERT for encoder
    SQL_Commands[3] := FC_SQL_InsertCommands_Encoder(iEncoderValue, iSampleNr);
	//INSERT for temp sensors
	SQL_Commands[4] := CONCAT(FC_SQL_InsertCommands_TempSensor(TempConvert(iTempSensor1Value), iSampleNr, iSensorIDs[1]),FC_SQL_InsertCommands_TempSensor(TempConvert(iTempSensor2Value), iSampleNr, iSensorIDs[2]));
	SQL_Commands[5] := CONCAT(FC_SQL_InsertCommands_TempSensor(TempConvert(iTempSensor3Value), iSampleNr, iSensorIDs[3]),FC_SQL_InsertCommands_TempSensor(	TempConvert(iTempSensor4Value), iSampleNr, iSensorIDs[4]));
	
	//enable Timer					  
	tInsertTimer(IN := TRUE, PT := tInsertInterval);
	//check if time passed
 IF tInsertTimer.Q THEN  				     
    //state machine for INSERT executes
	CASE nStep OF
	 0:
        //Execute Encoder INSERT
        IF FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[3]), cbSQLCmd := SIZEOF(SQL_Commands[3])) THEN
            nNextStep := 1;
        END_IF
		
	1:	//execute Temp 1 and 2 INSERT
		IF FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[4]), cbSQLCmd := SIZEOF(SQL_Commands[4])) THEN
            nNextStep := 2;
        END_IF
	2:	//execute Temp 3 and 4 INSERT
		IF FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[5]), cbSQLCmd := SIZEOF(SQL_Commands[5])) THEN
            nNextStep := 3;
        END_IF
	3:	
		// Properly reset and restart the timer
    	tInsertTimer(IN := FALSE); // Stop timer
    	tInsertTimer(IN := TRUE);  // Restart timer 
		nNextStep := 0;
	END_CASE
   //Advance the state machine step
	nStep := nNextStep;
	 	
END_IF
*)
	
	
	
	
	//HMI Controls
IF bConfirm AND HomingDone THEN
		TijdConvertUitwijking := INT_TO_TIME(iTijd) * 1000; //set to seconds
		TijdConvertMeting := INT_TO_TIME(iTijdMeting) * 1000; //set to seconds
		IF iEncoderMotor > 9 OR iEncoderMotor < -9 THEN
		iEncoderMotor := 0.0;
		END_IF
		IF iMotorSpeed < 100 OR iMotorSpeed > 1000 THEN
			iMotorSpeed := 500;
		END_IF
		bStartEnabled := TRUE;	
END_IF
	
//start measurements
IF bStart THEN
		
	
	CASE MeasurementState OF
		
	  0: // Initialize	
		Process_Status := TRUE;
        oMotorEnable := TRUE;
        oMotorVelocity := iMotorSpeed;
		//Create timers
		tUitwijkingTimer(PT := TijdConvertUitwijking); 
		tMetingTimer(PT := TijdConvertMeting); 
		//Insert Loadcell value at Start
		SQL_Commands[1] := FC_SQL_InsertCommands_LoadCell(LoadcellConvert(iLoadCellValue), iSampleNr);
		FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[1]), cbSQLCmd := SIZEOF(SQL_Commands[1]));
    	iSampleNr := iSampleNr + 1;
  
        MeasurementState := 1;
		
	
	  1: //Wait at start
	   	tMetingTimer(IN := TRUE); // Start timer  
		IF tMetingTimer.Q THEN 
		 	//wait before moving motor to chosen position
			IF iEncoderMotor > 0.1 THEN
			oMotorPosition := MotorLeftEdge; 
			ELSE
			oMotorPosition := MotorRightEdge;
			END_IF
			omotorExecute := TRUE;
			MeasurementState := 2; 	
	 	END_IF
		
		
	  2: //move to chosen degrees
		IF ABS(iEncoderDegrees - iEncoderMotor) < 0.1 THEN
			oMotorExecute := FALSE; //stop motor
			tMetingTimer(IN := FALSE); // Stop Metingtimer
			tUitwijkingTimer(IN := TRUE);  //start Uitijwkingtimer
		END_IF
		//wait at chosen degrees
	 	IF tUitwijkingTimer.Q THEN
			//Move motor back TO start position 
			oMotorPosition := oStartPosition;
		 	omotorExecute := TRUE;
			MeasurementState := 3; 	
	 	END_IF
	 
	  3: //restart measurement
		 IF RealMotorPosition = oStartPosition THEN
			 MeasurementsCompleted := Measurementscompleted + 1;
			 tUitwijkingTimer(IN := FALSE); // Stop timer
			 oMotorExecute := FALSE; //stop motor
    		 MeasurementState := 4;
		 END_IF
		 
	 4: //check if measurments are complete
	   IF MeasurementsCompleted = iMetingen THEN
		 bStop := TRUE;
	   ELSE
		measurementState := 1;	 
	   END_IF
	 
	END_CASE	
END_IF
	
	//end measurements
	IF bStop AND HomingDone THEN
		Process_Status := FALSE; //hmi update
		//disable motor
		//oMotorEnable := FALSE;
		oMotorExecute := FALSE;
		
		//stop plotting
	
		//reset state for next measurement
		MeasurementState := 0;
		
	END_IF
	

	END_IF
(*	
  // Prepare SELECT Query
        sSelectDataCommand := 'SELECT TOP(10) [SensorValue], [SampleNr], [Time], [SensorID] FROM [db_accessadmin].[TempSensor] ORDER BY TIME DESC;';
   
  // Execute SELECT Command
       FB_SQLCommandEvt.ExecuteDataReturn(ADR(sSelectDataCommand),
           							   SIZEOF(sSelectDataCommand),
            							   ADR(FB_SQLResultEvt)); 
					
  	FB_SQLResultEvt.Read(1, 10, ADR(aReadStruct), SIZEOF(aReadStruct), TRUE, TRUE);
*)	]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>