<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{4ef234f8-6ebd-4fcd-beba-a435a8463d67}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
    //database variables
	FB_SQLDatabaseEvt : FB_SQLDatabaseEvt(sNetID := '', tTimeout := T#5S);
    FB_SQLCommandEvt  : FB_SQLCommandEvt(sNetID := '', tTimeout := T#5S);
    FB_SQLResultEvt   : FB_SQLResultEvt(sNetID := '', tTimeout := T#5S);
	SQL_Commands: ARRAY[1..7] OF STRING(500);
	sSelectDataCommand : STRING(255);
	DataBase_Connection: BOOL := FALSE;
   
	//inputs from sensor
    iLoadCellValue AT %I*: INT;
	iLoadCellPreviousValue : INT;
	iTempSensor1Value AT %I*: INT;
	iTempSensor2Value AT %I*: INT;
	iTempSensor3Value AT %I*: INT;
	iTempSensor4Value AT %I*: INT;
	iEncoderValue AT %I*: INT;
	//Time variables
	tInsertTimer: TON; (* Timer to control insert intervals *)
    tInsertInterval: TIME := T#10S; (* 10-second interval *)
	

	//read arrays
	aReadStruct : ARRAY[1..10] OF TempSensor_SelectStruct;
	//Strings to insert
	sTempSensor1Value: STRING(255);
	sTempSensor2Value: STRING(255);
	sTempSensor3Value: STRING(255);
	sTempSensor4Value: STRING(255);
	iSampleNr: INT := 1;
	iSensorIDs : ARRAY[1..4] OF INT := [1,2,3,4];
	
	//state machine control
	nStep, nNextStep: INT ;
	//HMI variables
	iEncoderMotor : REAL;
	iLoadCellMotor : INT;
	iMetingen : INT;
	iTijd : INT;
	bConfirm : BOOL;
	
	
	bStart : BOOL;
	bStop : BOOL := TRUE;
	Process_Status : BOOL; 
	bStartEnabled: BOOL;
	bDatalogView : BOOL;
	bActuatorView : BOOL;
	
	//hmi control
	TijdConvert : TIME;
	tUitwijkingTimer: TON; (* Timer to control wait time *) 
	EncoderDegrees : REAL;
	MeasurementsCompleted : INT;
	MotorPosition : INT;
	
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
//make connection to the database
// Connect to Database (only once)
IF NOT DataBase_Connection THEN
    FB_SQLDatabaseEvt.Connect(hDBID := 1);  // Attempt to connect

    // Wait until the connection is established
    IF FB_SQLDatabaseEvt.bConnected THEN
        FB_SQLDatabaseEvt.CreateCmd(pSQLCommand := ADR(FB_SQLCommandEvt));
        DataBase_Connection := TRUE;
    END_IF;
END_IF
		
// Generate and insert LoadCell Data only when changed 
IF ABS(iLoadCellValue - iLoadCellPreviousValue) > 100  THEN
    SQL_Commands[1] := FC_SQL_InsertCommands_LoadCell(iLoadCellValue, iSampleNr);
	FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[1]), cbSQLCmd := SIZEOF(SQL_Commands[1]));
    iSampleNr := iSampleNr + 1;  // Increment sample number
    iLoadCellPreviousValue := iLoadCellValue;  // Update previous load cell value
END_IF


	
	//enable Timer					  
	tInsertTimer(IN := TRUE, PT := tInsertInterval);
	//check if time passed
 IF tInsertTimer.Q THEN  				     
    //state machine for INSERT executes
	CASE nStep OF
	 0:
        //Execute Encoder INSERT
        IF FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[3]), cbSQLCmd := SIZEOF(SQL_Commands[3])) THEN
            nNextStep := 1;
        END_IF
		
	1:	//execute Temp 1 and 2 INSERT
		IF FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[4]), cbSQLCmd := SIZEOF(SQL_Commands[4])) THEN
            nNextStep := 2;
        END_IF
	2:	//execute Temp 3 and 4 INSERT
		IF FB_SQLCommandEvt.Execute(pSQLCmd := ADR(SQL_Commands[5]), cbSQLCmd := SIZEOF(SQL_Commands[5])) THEN
            nNextStep := 3;
        END_IF
	3:	
		// Properly reset and restart the timer
    	tInsertTimer(IN := FALSE); // Stop timer
    	tInsertTimer(IN := TRUE);  // Restart timer 
		nNextStep := 0;
	END_CASE
   //Advance the state machine step
	nStep := nNextStep;
	 	
END_IF
	
	//HMI Controls
	IF bConfirm THEN
		TijdConvert := INT_TO_TIME(iTijd) * 1000;
		bStartEnabled := TRUE;	
	END_IF
	
	IF bStart THEN
		Process_Status := TRUE;
		//enable motor
		//start plotting
		
	END_IF
	IF bStop THEN
		Process_Status := FALSE;
		//disable motor
		//stop plotting	
	END_IF
	
	
	
	//complete desired number of measurements
	WHILE iMetingen <> MeasurementsCompleted DO
		
	tUitwijkingTimer(IN := FALSE, PT := tInsertInterval); //create timer
	
	//enable wait time for motor
	IF EncoderDegrees = iEncoderMotor THEN
		tUitwijkingTimer(IN := TRUE);  //start timer 
	END_IF
	
	 IF tUitwijkingTimer.Q THEN 
		 //move motor back to start position
		 
		 //restart measurement
		 IF MotorPosition = 0 THEN
			 MeasurementsCompleted := Measurementscompleted + 1;
			 tUitwijkingTimer(IN := FALSE); // Stop timer
    	
		 END_IF
	 END_IF
	 //end measurement
	 IF MeasurementsCompleted = iMetingen THEN
		 bStop := TRUE;
	 END_IF
	 
	 END_WHILE
  // Prepare SELECT Query
        sSelectDataCommand := 'SELECT TOP(10) [SensorValue], [SampleNr], [Time], [SensorID] FROM [db_accessadmin].[TempSensor] ORDER BY TIME DESC;';
   
  // Execute SELECT Command
       FB_SQLCommandEvt.ExecuteDataReturn(ADR(sSelectDataCommand),
           							   SIZEOF(sSelectDataCommand),
            							   ADR(FB_SQLResultEvt)); 
					
  	FB_SQLResultEvt.Read(1, 10, ADR(aReadStruct), SIZEOF(aReadStruct), TRUE, TRUE);]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>